#+OPTIONS: toc:nil
#+BEGIN_HTML
---
permalink: /portfolio/llkjs/
title: "Connect & Eliminate Game"
layout: single
author_profile: false
Excerpt: "A simple connect & eliminate puzzle written in Javascript"
header:
  teaser: "llkjs_portfolio.png"

gallery:
  - url: llkjs_gallery_1.png
    image_path: llkjs_gallery_1.png
    alt: "placeholder image 1"
  - url: llkjs_gallery_2.png
    image_path: llkjs_gallery_2.png
    alt: "placeholder image 2"
---

{% include base_path %}

{% capture fig_img %}
![Foo]({{ base_path }}/images/llk_rule.png)
{% endcapture %}
#+END_HTML

This is a quick game demo I wrote with JS with jQuery, underscore and
a 2D canvas rendering library called [[http://www.createjs.com/easeljs][EaselJS]]. 

Here is the [[http://www.magkbdev.com/llkjs][Live Demo]] and the [[https://github.com/stevegocoding/llkjs][GitHub Repo]]

{% include gallery %} 

** How to play:
+ Select one tile, looking for another one with same type to connect
  and eliminate. Two tiles are connected if:
  + There is a path (only up, right, down, left) between them, AND
  + The path has less than two (inclusive) turns.

#+BEGIN_HTML
<figure>
  {{ fig_img | markdownify | remove: "<p>" | remove: "</p>" }}
  <figcaption>Connection Rule</figcaption>
</figure>
#+END_HTML

** Implementation:
For connection detection, a DFS (depth-first search) would do the
trick, limit and number of turns (pass current turns of directions
when recurs down) and save the path for drawing. 

All the assets in the game are collected from
[[http://opengameart.org/][OpenGameArt]] - A nice collection of free
art can be used in games. The tiles are put into a tile sheet and I
wrote a JSON file to describe which tile I'd like to use and their
offsets relative to upper-left corner of the tile sheet. 

Like this:
#+BEGIN_HTML
{% highlight javascript %}
[ 
  {
    "name": "golden_blank",
    "sheet": "tilesheet",
    "x": 4,
    "y": 4,
    "width": 32,
    "height": 32
  },
  {
    "name": "green_cross",
    "sheet": "tilesheet",
    "x": 36,
    "y": 36,
    "width": 32,
    "height": 32
  }
]
{% endhighlight %}
#+END_HTML

Lastly, here is the DFS algorithm for the connection detection:
#+BEGIN_HTML
{% highlight javascript %}
    /** 
     * A Depth-First-Search algorithm that finds if there is 
     * any path between two points in a grid that has NO MORE THAN 2
     * re-directions.
     * 
     * Params: 
     *    x - current grid x coord
     *    y - current grid y coord
     *    dx - destination grid x coord
     *    dy - destination grid y coord
     *    dir - the direction taken when moving from previous cell to current one 
     *    numRedir - current number of re-directions
     *    path - an array that keeps track of the searching path 
     **/    
    exp.dfs = function(x, y, dx, dy, dir, numRedir, path) {
      if (found || numRedir > 2) { return; }
      if (x === dx && y === dy) { 
        found = true; 
        foundPath.push(path.slice(0));
        return; 
      }
      
      // Try all 4 directions from current cell
      for (var i = 0; i < 4; ++i) {
        // Get next cell coords nx, ny based on direction
        var nx = x + dirs[i][0];
        var ny = y + dirs[i][1];
        
        // Direction of next step
        var nd = i; 
        
        if (nx >= 0 && nx <= this._boardData.numTiles - 1 && 
            ny >= 0 && ny <= this._boardData.numTiles - 1 && 
            (this.isTileWalkable(nx, ny) || (nx === dx && ny === dy)) && 
            !this.isTileVisited(nx, ny)) {
         
          if (numRedir <= 2) {
            // when we start from this tile (dir === -1), we don't increase re-direction
            if (dir === -1 && numRedir <= 2) { 
              this.markTileVisited(nx, ny);
              path.push({x: nx, y: ny});
              this.dfs(nx, ny, dx, dy, i, numRedir, path);
              path.pop(); // back-tracing
              this.clearVisited(nx, ny);
            } 
            // still the same direction, keep searching
            if (dir === i && numRedir <= 2) {
              this.markTileVisited(nx, ny);
              path.push({x: nx, y: ny});
              this.dfs(nx, ny, dx, dy, dir, numRedir, path);
              path.pop(); // back-tracing
              this.clearVisited(nx, ny);
            }
            // re-direction, increase numRedir
            if ((nd !== dir && dir !== -1) && numRedir <= 2) { 
              this.markTileVisited(nx, ny);
              path.push({x: nx, y: ny});
              this.dfs(nx, ny, dx, dy, i, numRedir+1, path);
              path.pop(); // back-tracing
              this.clearVisited(nx, ny);
            }  
          }
        }
      }
    }
{% endhighlight %}
#+END_HTML
