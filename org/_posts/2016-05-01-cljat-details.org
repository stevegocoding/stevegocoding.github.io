#+OPTIONS: toc:nil
#+BEGIN_HTML
---
title: "A Bite of Clojure - Sweet"
excerpt: Some development details of the Cljat project.
categories: 
- Dev
- Portfolio
tags:
- Clojure
- Clojurescript
- Redis
---

{% include base_path %}

{% capture fig_img %}
![Foo]({{ base_path }}/images/cljat_design.png)
{% endcapture %}
#+END_HTML

After spending weeks of my spare time fiddling with Clojure, I
finally put together a simple websocket chat web application -
@@html:<a href="/portfolio/cljat">@@ Cljat @@html:</a>@@.

** System Design


The whole system includes:
- Clojurescript front end application.
- Web Server that handles http and websocket connections.
- A Redis client that uses PUB/SUB and named MQ.
- A PostgreSQL database for chat messages persistent.

#+BEGIN_HTML
<figure>
  {{ fig_img | markdownify | remove: "<p>" | remove: "</p>" }}
  <figcaption>System Overview</figcaption>
</figure>
#+END_HTML

*** Web Layer
The web servers are handling http requests and websocket messages. I
used [[http://www.http-kit.org/][HttpKit]] as the http server that
supports websocket as well. It is implemented with Java's Non-blocking
IO package to be capable of handling massive concurrent
connection and it has a nice Clojure API.

*** Message Layer
Redis plays a critical role in this system. I used it's fast PUB/SUB
messaging feature to dispatch messages across the web servers as the
users who are chatting in the same thread might be connected to
different server node in a cluster. When an user is logged in and
connected to a web node, that node SUB all the threads that users
currently has on Redis. When an user send a message on a thread, a
message is PUBed by Redis and all the web servers that SUBed will
receive it.

Redis is also a cache here. When a web server receives a message PUBed
by Redis, it will look up the user's id of whom is connected to it and has
this thread since it needs the user id to push the message to
specific client over websocket.

*** Persistent Layer
Again, Redis becomes a MQ here. It enqueues the chat messages when it
receives from web server and there is a worker on the other side of
the MQ consuming the message and inserting it to DB. 

** Implementation Details

*** Server Side
The server side of the application is implemented with
[[https://github.com/stuartsierra/component][Suart Sierra's
Component library]] and pairs with the Reloaded workflow and Clojure's
awesome REPL, development becomes so fun and productive. I can quickly
refresh for code changes and reset system's states with a key
stroke, or try things out in REPL without messing with the application
code.

@TODO: system's components

Another powerful weapon of Clojure as
[[https://www.youtube.com/watch?v=ROor6_NGIWU][the language the
system]] is the core.async library. The components talk to
each other via queue-like channels asynchronously. It is like you have
several conveyor belts running between components and each component
doesn't know about others.

@TODO: core.async example

** Wrap Up
It was a fun project and I learned a lot from it. I guess I will
maintain it for quite a while and see how it goes.
