---
permalink: /portfolio/llkjs/
title: "A Tile-Matching Game"
layout: single
author_profile: false
excerpt: "A simple tile-matching puzzle written in Javascript"
header:
  teaser: "llkjs_portfolio.png"

gallery:
  - url: llkjs_gallery_1.png
    image_path: llkjs_gallery_1.png
    alt: "placeholder image 1"
  - url: llkjs_gallery_2.png
    image_path: llkjs_gallery_2.png
    alt: "placeholder image 2"
---

{% include base_path %}

{% capture fig_img %}
![Foo]({{ base_path }}/images/llk_rule.png)
{% endcapture %}

<p>
This is a quick game demo I wrote with JS with jQuery, underscore and
a 2D canvas rendering library called <a href="http://www.createjs.com/easeljs">EaselJS</a>. 
</p>

<p>
Here is the <a href="http://www.magkbdev.com/llkjs">Live Demo</a> and the <a href="https://github.com/stevegocoding/llkjs">GitHub Repo</a>
</p>

<p>
{% include gallery %} 
</p>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">How to play:</h2>
<div class="outline-text-2" id="text-1">
<ul class="org-ul">
<li>Select one tile, looking for another one with same type to connect
and eliminate. Two tiles are connected if:
<ul class="org-ul">
<li>There is a path (only up, right, down, left) between them, AND
</li>
<li>The path has less than two (inclusive) turns.
</li>
</ul>
</li>
</ul>

<figure>
  {{ fig_img | markdownify | remove: "<p>" | remove: "</p>" }}
  <figcaption>Connection Rule</figcaption>
</figure>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Implementation:</h2>
<div class="outline-text-2" id="text-2">
<p>
For connection detection, a DFS (depth-first search) would do the
trick, limit and number of turns (pass current turns of directions
when recurs down) and save the path for drawing. 
</p>

<p>
All the assets in the game are collected from
<a href="http://opengameart.org/">OpenGameArt</a> - A nice collection of free
art can be used in games. The tiles are put into a tile sheet and I
wrote a JSON file to describe which tile I'd like to use and their
offsets relative to upper-left corner of the tile sheet. 
</p>

<p>
Like this:
</p>
{% highlight javascript %}
[ 
  {
    "name": "golden_blank",
    "sheet": "tilesheet",
    "x": 4,
    "y": 4,
    "width": 32,
    "height": 32
  },
  {
    "name": "green_cross",
    "sheet": "tilesheet",
    "x": 36,
    "y": 36,
    "width": 32,
    "height": 32
  }
]
{% endhighlight %}

<p>
Lastly, here is the DFS algorithm for the connection detection:
</p>
{% highlight javascript %}
    /** 
     * A Depth-First-Search algorithm that finds if there is 
     * any path between two points in a grid that has NO MORE THAN 2
     * re-directions.
     * 
     * Params: 
     *    x - current grid x coord
     *    y - current grid y coord
     *    dx - destination grid x coord
     *    dy - destination grid y coord
     *    dir - the direction taken when moving from previous cell to current one 
     *    numRedir - current number of re-directions
     *    path - an array that keeps track of the searching path 
     **/    
    exp.dfs = function(x, y, dx, dy, dir, numRedir, path) {
      if (found || numRedir > 2) { return; }
      if (x === dx && y === dy) { 
        found = true; 
        foundPath.push(path.slice(0));
        return; 
      }
      
      // Try all 4 directions from current cell
      for (var i = 0; i < 4; ++i) {
        // Get next cell coords nx, ny based on direction
        var nx = x + dirs[i][0];
        var ny = y + dirs[i][1];
        
        // Direction of next step
        var nd = i; 
        
        if (nx >= 0 && nx <= this._boardData.numTiles - 1 && 
            ny >= 0 && ny <= this._boardData.numTiles - 1 && 
            (this.isTileWalkable(nx, ny) || (nx === dx && ny === dy)) && 
            !this.isTileVisited(nx, ny)) {
         
          if (numRedir <= 2) {
            // when we start from this tile (dir === -1), we don't increase re-direction
            if (dir === -1 && numRedir <= 2) { 
              this.markTileVisited(nx, ny);
              path.push({x: nx, y: ny});
              this.dfs(nx, ny, dx, dy, i, numRedir, path);
              path.pop(); // back-tracing
              this.clearVisited(nx, ny);
            } 
            // still the same direction, keep searching
            if (dir === i && numRedir <= 2) {
              this.markTileVisited(nx, ny);
              path.push({x: nx, y: ny});
              this.dfs(nx, ny, dx, dy, dir, numRedir, path);
              path.pop(); // back-tracing
              this.clearVisited(nx, ny);
            }
            // re-direction, increase numRedir
            if ((nd !== dir && dir !== -1) && numRedir <= 2) { 
              this.markTileVisited(nx, ny);
              path.push({x: nx, y: ny});
              this.dfs(nx, ny, dx, dy, i, numRedir+1, path);
              path.pop(); // back-tracing
              this.clearVisited(nx, ny);
            }  
          }
        }
      }
    }
{% endhighlight %}
</div>
</div>
