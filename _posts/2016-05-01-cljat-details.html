---
title: "A Bite of Clojure - Sweet"
excerpt: Some development details of the Cljat project.
categories: 
- Dev
- Portfolio
tags:
- Clojure
- Clojurescript
- Redis
---

{% include base_path %}

{% capture fig_img %}
![Foo]({{ base_path }}/images/cljat_design.png)
{% endcapture %}

<p>
After spending weeks of my spare time fiddling with Clojure, I
finally put together a simple websocket chat web application -
<a href="http:/portfolio/cljat">Cljat</a>
</p>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">System Design</h2>
<div class="outline-text-2" id="text-1">
<p>
The whole system includes:
</p>
<ul class="org-ul">
<li>Clojurescript front end application.
</li>
<li>Web Server that handles http and websocket connections.
</li>
<li>A Redis client that uses PUB/SUB and named MQ.
</li>
<li>A PostgreSQL database for chat messages persistent.
</li>
</ul>

<figure>
  {{ fig_img | markdownify | remove: "<p>" | remove: "</p>" }}
  <figcaption>System Overview</figcaption>
</figure>
</div>

<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">Web Layer</h3>
<div class="outline-text-3" id="text-1-1">
<p>
The web servers are handling http requests and websocket messages. I
used <a href="http://www.http-kit.org/">HttpKit</a> as the http server that
supports websocket as well. It is implemented with Java's Non-blocking
IO package to be capable of handling massive concurrent
connection and it has a nice Clojure API.
</p>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">Message Layer</h3>
<div class="outline-text-3" id="text-1-2">
<p>
Redis plays a critical role in this system. I used it's fast PUB/SUB
messaging feature to dispatch messages across the web servers as the
users who are chatting in the same thread might be connected to
different server node in a cluster. When an user is logged in and
connected to a web node, that node SUB all the threads that users
currently has on Redis. When an user send a message on a thread, a
message is PUBed by Redis and all the web servers that SUBed will
receive it.
</p>

<p>
Redis is also a cache here. When a web server receives a message PUBed
by Redis, it will look up the user's id of whom is connected to it and has
this thread since it needs the user id to push the message to
specific client over websocket.
</p>
</div>
</div>

<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3">Persistent Layer</h3>
<div class="outline-text-3" id="text-1-3">
<p>
Again, Redis becomes a MQ here. It enqueues the chat messages when it
receives from web server and there is a worker on the other side of
the MQ consuming the message and inserting it to DB. 
</p>
</div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Implementation Details</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">Server Side</h3>
<div class="outline-text-3" id="text-2-1">
<p>
The server side of the application is implemented with
<a href="https://github.com/stuartsierra/component">Suart Sierra's Component library</a> and pairs with the Reloaded workflow and Clojure's
awesome REPL, development becomes so fun and productive. I can quickly
refresh for code changes and reset system's states with a key
stroke, or try things out in REPL without messing with the application
code.
</p>

<p>
@TODO: system's components
</p>
{% highlight clojure %}
(defn system [sys-config]
  (-> (component/system-map
       ;; The core.async channel from ws handler to message router
       :ws-router-ch (a/chan)

       ;; The core.async channel from message router to ws handler 
       :router-ws-ch (a/chan)

       ;; Redis client
       :redis (new-redis-server (:redis sys-config))

       ;; Database
       :db (new-db (:db sys-config))

       ;; A worker that handles the websocket messages to put them on an outgoing channel 
       :ws-handler (new-ws-handler)

       ;; A worker that take a message from an incoming channel, publish to redis and-
       ;; put the response message on an outgoing channel
       :msg-router (new-msg-router)

       ;; Compojure route
       :routes (new-endpoint (:auth sys-config) new-app-routes)

       ;; Http-kit server
       :web-server (new-web-server (:web sys-config)))
      
      (component/system-using
        {:ws-handler {:in-ch :router-ws-ch 
                      :out-ch :ws-router-ch 
                      :redis :redis}

         :msg-router {:in-ch :ws-router-ch
                      :out-ch :router-ws-ch
                      :redis :redis}

         :routes [:db :ws-handler]
        
         :web-server [:routes]

         :redis [:db]})))
{% endhighlight %}

<p>
Another powerful weapon of Clojure as
<a href="https://www.youtube.com/watch?v=ROor6_NGIWU">the language the
system</a> is the core.async library. The components talk to
each other via queue-like channels asynchronously. It is like you have
several conveyor belts running between components and each component
doesn't know about others.
</p>

<p>
@TODO: core.async example
</p>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">Wrap Up</h2>
<div class="outline-text-2" id="text-3">
<p>
It was a fun project and I learned a lot from it. I guess I will
maintain it for quite a while and see how it goes.
</p>
</div>
</div>
